# ГЛАВА 10. Индексаторы и свойства
В этой главе рассматриваются две особые и тесно свя­
занные друг с другом разновидности членов класса:
индексаторы и свойства. Каждый из них по-своему
расширяет возможности класса, способствуя более полной
его интеграции в систему типов С# и повышая его гибкость.
В частности, индексаторы предоставляют механизм для ин­
дексирования объектов подобно массивам, а свойства — ра­
циональный способ управления доступом к данным экзем­
пляра класса. Эти члены класса тесно связаны друг с дру­
гом, поскольку оба опираются на еще одно доступное в C#
средство: аксессор.

## Индексаторы
Как вам должно быть уже известно, индексирование
массива осуществляется с помощью оператора []. Для
создаваемых классов можно определить оператор [],
но с этой целью вместо операторного метода создается
индексатор, который позволяет индексировать объект, по­
добно массиву. Индексаторы применяются, главным об­
разом, в качестве средства, поддерживающего создание
специализированных массивов, на которые накладывается
одно или несколько ограничений. Тем не менее индексато­
ры могут служить практически любым целям, для которых
выгодным оказывается такой же синтаксис, как и у масси­
вов. Индексаторы могут быть одно- или многомерными.
Рассмотрим сначала одномерные индексаторы.

### Создание одномерных индексаторов
Ниже приведена общая форма одномерного индексатора:
```
тип_элемента this[int индекс] {
    // Аксессор для получения данных.
    get {
        // Возврат значения, которое определяет индекс.
    }
    // Аксессор для установки данных.
    set {
        // Установка значения, которое определяет индекс.
    }
}
```
где тип_элемента обозначает конкретный тип элемента индексатора. Следовательно,
у каждого элемента, доступного с помощью индексатора, должен быть определенный
тип_элемента. Этот тип соответствует типу элемента массива. Параметр индекс по­
лучает конкретный индекс элемента, к которому осуществляется доступ. Формально
этот параметр совсем не обязательно должен иметь тип int, но поскольку индексато­
ры, как правило, применяются для индексирования массивов, то чаще всего использу­
ется целочисленный тип данного параметра.

В теле индексатора определены два аксессора (т.е. средства доступа к данным): get
и set. Аксессор подобен методу, за исключением того, что в нем не объявляется тип
возвращаемого значения или параметры. Аксессоры вызываются автоматически при
использовании индексатора, и оба получают индекс в качестве параметра. Так, если
индексатор указывается в левой части оператора присваивания, то вызывается аксессор
set и устанавливается элемент, на который указывает параметр индекс. В противном
случае вызывается аксессор get и возвращается значение, соответствующее параметру
индекс. Кроме того, аксессор set получает неявный параметр value, содержащий
значение, присваиваемое по указанному индексу.

Преимущество индексатора заключается, в частности, в том, что он позволяет пол­
ностью управлять доступом к массиву, избегая нежелательного доступа. В качестве
примера рассмотрим программу, в которой создается класс FailSoftArray, реали­
зующий массив для выявления ошибок нарушения границ массива, а следовательно,
для предотвращения исключительных ситуаций, возникающих во время выполнения
в связи с индексированием массива за его границами. Для этого массив инкапсулиру­
ется в качестве закрытого члена класса, а доступ к нему осуществляется только с помо­
щью индексатора. При таком подходе исключается любая попытка получить доступ
к массиву за его границами, причем эта попытка пресекается без катастрофических
последствий для программы. А поскольку в классе FailSoftArray используется ин­
дексатор, то к массиву можно обращаться с помощью обычной формы записи.
```
// Использовать индексатор для создания отказоустойчивого массива.
using System;

class FailSoftArray {
    int[] a; // ссылка на базовый массив
    public int Length; // открытая переменная длины массива
    public bool ErrFlag; // обозначает результат последней операции
    // Построить массив заданного размера.
    public FailSoftArray(int size) {
    a = new int[size];
    Length = size;
    }
    // Это индексатор для класса FailSoftArray.
    public int this[int index] {
        // Это аксессор get.
        get {
            if(ok(index)) {
                ErrFlag = false;
                return a[index];
            } else {
                ErrFlag = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            if(ok(index)) {
                a[index] = value;
                ErrFlag = false;
            }
            else ErrFlag = true;
        }
    }
    // Возвратить логическое значение true, если
    // индекс находится в установленных границах.
    private bool ok(int index) {
        if(index >= 0 & index < Length) return true;
        return false;
    }
}

// Продемонстрировать применение отказоустойчивого массива.
class FSDemo {
    static void Main() {
        FailSoftArray fs = new FailSoftArray(5);
        int x;
        // Выявить скрытые сбои.
        Console.WriteLine("Скрытый сбой.");
        for(int i=0; i < (fs.Length * 2); i++)
            fs[i] = i*10;
        for(int i=0; i < (fs.Length * 2); i++) {
            x = fs[i];
            if(x != -1) Console.Write(x + " ");
        }
        Console.WriteLine();

        // А теперь показать сбои.
        Console.WriteLine("\nСбой с уведомлением об ошибках.");
        for (int i=0; i < (fs.Length * 2); i++) {
            fs[i] = i * 10;
            if(fs.ErrFlag)
                Console.WriteLine("fs[" + i + "] вне границ");
        }
        for(int i=0; i < (fs.Length * 2); i++) {
            x = fs[i];
            if(!fs.ErrFlag) Console.Write(x + " ");
            else
                Console.WriteLine("fs[" + i + "] вне границ");
        }
    }
}
```
Вот к какому результату приводит выполнение этой программы.
```
Скрытый сбой.
0 10 20 30 40 0 0 0 0 0

Сбой с уведомлением об ошибках.
fs[5] вне границ
fs[6] вне границ
fs[7] вне границ
fs[8] вне границ
fs[9] вне границ
0 10 20 30 40 fs[5] вне границ
fs[6] вне границ
fs[7] вне границ
fs[8] вне границ
fs[9] вне границ
```
Индексатор препятствует нарушению границ массива. Внимательно проанализи­
руем каждую часть кода индексатора. Он начинается со следующей строки.
```
public int this[int index] {
```
В этой строке кода объявляется индексатор, оперирующий элементами типа int.
Ему передается индекс в качестве параметра index. Кроме того, индексатор объявля­
ется открытым (public), что дает возможность использовать этот индексатор в коде за
пределами его класса.

Рассмотрим следующий код аксессора get.
```
get {
    if(ok(index)) {
        ErrFlag = false;
        return a[index];
    } else {
        ErrFlag = true;
        return 0;
    }
}
```
Аксессор get предотвращает ошибки нарушения границ массива, проверяя в пер­
вую очередь, находится ли индекс в установленных границах. Эта проверка границ вы­
полняется в методе ok(), который возвращает логическое значение true, если индекс
правильный, а иначе — логическое значение false. Так, если указанный индекс на­
ходится б установленных границах, то по этому индексу возвращается соответствую­
щий элемент. А если индекс оказывается вне установленных границ, то никаких опе­
раций не выполняется, но в то же время не возникает никаких ошибок переполнения.
В данном варианте класса FailSoftArray переменная ErrFlag содержит результат
каждой операции. Ее содержимое может быть проверено после каждой операции на
предмет удачного или неудачного выполнения последней. (В главе 13 будет представ­
лен более совершенный способ обработки ошибок с помощью имеющейся в C# под­
системы обработки исключительных ситуаций, а до тех пор можно вполне обойтись
установкой и проверкой признака ошибки.)

А теперь рассмотрим следующий код аксессора set, предотвращающего ошибки
нарушения границ массива.
```
set {
    if(ok(index)) {
        a[index] = value;
        ErrFlag = false;
    }
    else ErrFlag = true;
}
```
Если параметр index метода ok() находится в установленных пределах, то соот­
ветствующему элементу массива присваивается значение, передаваемое из параметра
value. В противном случае устанавливается логическое значение true переменной
ErrFlag. Напомним, что value в любом аксессорном методе является неявным пара­
метром, содержащим присваиваемое значение. Его не нужно (да и нельзя) объявлять
отдельно.

Наличие обоих аксессоров, get и set, в индексаторе не является обязательным.
Так, можно создать индексатор только для чтения, реализовав в нем один лишь аксес­
сор get, или же индексатор только для записи с единственным аксессором set.

### Перегрузка индексаторов
Индексатор может быть перегружен. В этом случае для выполнения выбирается
тот вариант индексатора, в котором точнее соблюдается соответствие его параметра и
аргумента, указываемого в качестве индекса. Ниже приведен пример программы, в ко­
торой индексатор массива класса FailSoftArray перегружается для индексов типа
double. При этом индексатор типа double округляет свой индекс до ближайшего
целого значения.
```
// Перегрузить индексатор массива класса FailSoftArray.
using System;

class FailSoftArray {
    int[] a; // ссылка на базовый массив
    public int Length; // открытая переменная длины массива
    public bool ErrFlag; // обозначает результат последней операции
    // Построить массив заданного размера.
    public FailSoftArray(int size) {
        a = new int[size];
        Length = size;
    }
    // Это индексатор типа int для массива FailSoftArray.
    public int this[int index] {
        // Это аксессор get.
        get {
            if(ok(index)) {
                ErrFlag = false;
                return a[index];
            } else {
                ErrFlag = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            if(ok(index)) {
                a[index] = value;
                ErrFlag = false;
            }
            else ErrFlag = true;
        }
    }
    /* Это еще один индексатор для массива FailSoftArray.
    Он округляет свой аргумент до ближайшего целого индекса. */
    public int this[double idx] {
        // Это аксессор get.
        get {
            int index;
            // Округлить до ближайшего целого.
            if( (idx - (int) idx) < 0.5) index = (int) idx;
            else index = (int) idx + 1;
            if(ok(index)) {
                ErrFlag = false;
                return a[index];
            } else {
                ErrFlag = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            int index;
            // Округлить до ближайшего целого.
            if( (idx - (int) idx) < 0.5) index = (int) idx;
            else index = (int) idx + 1;
            if(ok(index)) {
                a[index] = value;
                ErrFlag = false;
            }
            else ErrFlag = true;
        }
    }
    // Возвратить логическое значение true, если
    // индекс находится в установленных границах.
    private bool ok(int index) {
        if (index >= 0 & index < Length) return true;
        return false;
    }
}

// Продемонстрировать применение отказоустойчивого массива.
class FSDemo {
    static void Main() {
        FailSoftArray fs = new FailSoftArray(5);
        // Поместить ряд значений в массив fs.
        for(int i=0; i < fs.Length; i++)
            fs[i] = i;
        // А теперь воспользоваться индексами
        // типа int и double для обращения к массиву.
        Console.WriteLine("fs[1] : " + fs[1]);
        Console.WriteLine("fs[2] : " + fs[2]);
        Console.WriteLine("fs[1.1]: " + fs[l.l]);
        Console.WriteLine("fs[1.6]: " + fs[1.6]);
    }
}
```
При выполнении этой программы получается следующий результат.
```
fs[1]: 1
fs[2]: 2
fs[1.1]: 1
fs[1.6]: 2
```
Как показывает приведенный выше результат, индексы типа double округляются
до ближайшего целого значения. В частности, индекс 1.1 округляется до 1, а индекс
1.6 — до 2.

Представленный выше пример программы наглядно демонстрирует правомоч­
ность перегрузки индексаторов, но на практике она применяется нечасто. Как прави­
ло, индексаторы перегружаются для того, чтобы использовать объект определенного
класса в качестве индекса, вычисляемого каким-то особым образом.

### Индексаторы без базового массива
Следует особо подчеркнуть, что индексатор совсем не обязательно должен опери­
ровать массивом. Его основное назначение — предоставить пользователю функцио­
нальные возможности, аналогичные массиву. В качестве примера в приведенной ниже
программе демонстрируется индексатор, выполняющий роль массива только для чте­
ния, содержащего степени числа 2 от 0 до 15. Обратите внимание на то, что в этой
программе отсутствует конкретный массив. Вместо этого индексатор просто вычисляет
подходящее значение для заданного индекса.
```
// Индексаторы совсем не обязательно должны оперировать отдельными
массивами.
using System;

class PwrOfTwo {
    /* Доступ к логическому массиву, содержащему степени
    числа 2 от 0 до 15. */
    public int this[int index] {
        // Вычислить и возвратить степень числа 2.
        get {
            if((index >= 0) && (index < 16)) return pwr(index);
            else return -1;
        }
        // Аксессор set отсутствует.
    }
    int pwr(int p) {
        int result = 1;
        for(int i=0; i < p; i++)
            result *= 2;
        return result;
    }
}

class UsePwrOfTwo {
    static void Main() {
        PwrOfTwo pwr = new PwrOfTwo();
        Console.Write("Первые 8 степеней числа 2: ");
        for(int i=0; i < 8; i++)
            Console.Write(pwr[i] + " ");
        Console.WriteLine();

        Console.Write("А это некоторые ошибки: ");
        Console.Write(pwr[-1] + " " + pwr[17]);
        Console.WriteLine();
    }
}
```
Вот к какому результату приводит выполнение этой программы.
```
Первые 8 степеней числа 2: 1 2 4 8 16 32 64 128
А это некоторые ошибки: -1 -1
```
Обратите внимание на то, что в индексатор класса PwrOfTwo включен только аксес­
сор get, но в нем отсутствует аксессор set. Как пояснялось выше, такой индексатор
служит только для чтения. Следовательно, объект класса PwrOfTwo может указываться
только в правой части оператора присваивания, но не в левой его части. Например,
попытка ввести следующую строку кода в приведенную выше программу не приведет
к желаемому результату.
```
pwr[0] = 11; // не подлежит компиляции
```
Такой оператор присваивания станет причиной появления ошибки во время ком­
пиляции, поскольку для индексатора не определен аксессор set.

На применение индексаторов накладываются два существенных ограничения.
Во-первых, значение, выдаваемое индексатором, нельзя передавать методу в качестве
параметра ref или out, поскольку в индексаторе не определено место в памяти для
его хранения. И во-вторых, индексатор должен быть членом своего класса и поэтому
не может быть объявлен как static.

### Многомерные индексаторы
Индексаторы можно создавать и для многомерных массивов. В качестве примера
ниже приведен двумерный отказоустойчивый массив. Обратите особое внимание на
объявление индексатора в этом примере.
```
// Двумерный отказоустойчивый массив.
using System;

class FailSoftArray2D {
    int[,] a; // ссылка на базовый двумерный массив
    int rows, cols; // размеры массива
    public int Length; // открытая переменная длины массива
    public bool ErrFlag; // обозначает результат последней операции
    // Построить массив заданных размеров.
    public FailSoftArray2D(int r, int с) {
        rows = r;
        cols = с;
        а = new int[rows, cols];
        Length = rows * cols;
    }
    // Это индексатор для класса FailSoftArray2D.
    public int this[int index1, int index2] {
        // Это аксессор get.
        get {
            if(ok(index1, index2)) {
                ErrFlag = false;
                return a[index1, index2];
            } else {
                ErrFlag = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            if(ok(index1, index2)) {
                a[index1, index2] = value;
                ErrFlag = false;
            }
            else ErrFlag = true;
        }
    }
    // Возвратить логическое значение true, если
    // индексы находятся в установленных пределах.
    private bool ok(int index1, int index2) {
        if (index1 >= 0 & index1 < rows &
        index2 >= 0 & index2 < cols)
            return true;
        return false;
    }
}

// Продемонстрировать применение двумерного индексатора.
class TwoDIndexerDemo {
    static void Main() {
        FailSoftArray2D fs = new FailSoftArray2D(3, 5);
        int x;
        // Выявить скрытые сбои.
        Console.WriteLine("Скрытый сбой.");
        for (int i=0; i < 6; i++)
            fs[i, i] = i*10;
        for(int i=0; i < 6; i++) {
            x = fs[i,i];
            if(x != -1) Console.Write(x + " ");
        }
        Console.WriteLine();

        // А теперь показать сбои.
        Console.WriteLine("\nСбой с уведомлением об ошибках.");
        for(int i=0; i < 6; i++) {
            fs[i,i] = i*10;
            if(fs.ErrFlag)
                Console.WriteLine("fs[" + i + ", " + i + "] вне границ");
        }
        for(int i=0; i < 6; i++) {
            x = fs[i,i];
            if(!fs.ErrFlag) Console.Write(x + " ");
            else
                Console.WriteLine("fs[" + i + ", " + i + "] вне границ");
        }
    }
}
```
Вот к какому результату приводит выполнение этого кода:
```
Скрытый сбой.
0 10 20 0 0 0

Сбой с уведомлением об ошибках.
fs[3, 3] вне границ
fs[4, 4] вне границ
fs[5, 5] вне границ
0 10 20 fs[3, 3] вне границ
fs[4, 4] вне границ
fs[5, 5] вне границ
```

## Свойства
Еще одной разновидностью члена класса является свойство. Как правило, свойство
сочетает в себе поле с методами доступа к нему. Как было показано в приведенных
ранее примерах программ, поле зачастую создается, чтобы стать доступным для поль­
зователей объекта, но при этом желательно сохранить управление над операциями,
разрешенными для этого поля, например, ограничить диапазон значений, присваи­
ваемых данному полю. Этой цели можно, конечно, добиться и с помощью закрытой
переменной, а также методов доступа к ее значению, но свойство предоставляет более
совершенный и рациональный путь для достижения той же самой цели.

Свойства очень похожи на индексаторы. В частности, свойство состоит из имени и
аксессоров get и set. Аксессоры служат для получения и установки значения пере­
менной. Главное преимущество свойства заключается в том, что его имя может быть
использовано в выражениях и операторах присваивания аналогично имени обычной
переменной, но в действительности при обращении к свойству по имени автоматиче­
ски вызываются его аксессоры get и set. Аналогичным образом используются аксес­
соры get и set индексатора.

Ниже приведена общая форма свойства:
```
тип имя {
    get {
        // код аксессора для чтения из поля
    }
    set {
    // код аксессора для записи в поле
    }
```
где тип обозначает конкретный тип свойства, например int, а имя — присваиваемое
свойству имя. Как только свойство будет определено, любое обращение к свойству по
имени приведет к автоматическому вызову соответствующего аксессора. Кроме того,
аксессор set принимает неявный параметр value, который содержит значение, при­
сваиваемое свойству.

Следует, однако, иметь в виду, что свойства не определяют место в памяти для хра­
нения полей, а лишь управляют доступом к полям. Это означает, что само свойство не
предоставляет поле, и поэтому поле должно быть определено независимо от свойства.
(Исключение из этого правила составляет автоматически реализуемое свойство, рассма­
триваемое далее.)

Ниже приведен простой пример программы, в которой определяется свойство
MyProp, предназначенное для доступа к полю prop. В данном примере свойство до­
пускает присваивание только положительных значений.
```
// Простой пример применения свойства.
using System;

class SimpProp {
    int prop; // поле, управляемое свойством МуРrор
    public SimpProp() { prop = 0; }
    /* Это свойство обеспечивает доступ к закрытой переменной экземпляра prop.
    Оно допускает присваивание только положительных значений. */
    public int MyProp {
        get {
            return prop;
        }
        set {
            if(value >= 0) prop = value;
        }
    }
}

// Продемонстрировать применение свойства.
class PropertyDemo {
    static void Main() {
        SimpProp ob = new SimpProp();
        Console.WriteLine("Первоначальное значение ob.МуРrор: " + ob.МуРrор);
        ob.МуРrор = 100; // присвоить значение
        Console.WriteLine("Текущее значение ob.МуРrор: " + ob.МуРrор);
        // Переменной prop нельзя присвоить отрицательное значение.
        Console.WriteLine("Попытка присвоить значение " +
                        "-10 свойству ob.МуРrор");
        ob.МуРrор = -10;
        Console.WriteLine("Текущее значение ob.МуРrор: " + ob.МуРrор);
    }
}
```
Вот к какому результату приводит выполнение этого кода.
```
Первоначальное значение ob.МуРrор: 0
Текущее значение ob.МуРrор: 100
Попытка присвоить значение -10 свойству ob.МуРrор
Текущее значение ob.МуРrор: 100
```
Рассмотрим приведенный выше код более подробно. В этом коде определяется
одно закрытое поле prop и свойство MyProp, управляющее доступом к полю prop.
Как пояснялось выше, само свойство не определяет место в памяти для хранения поля,
а только управляет доступом к полю. Кроме того, поле prop является закрытым, а зна­
чит, оно доступно только через свойство MyProp.

Свойство MyProp указано как public, а следовательно, оно доступно из кода за
пределами его класса. И в этом есть своя логика, поскольку данное свойство обеспе­
чивает доступ к полю prop, которое является закрытым. Аксессор get этого свойства
просто возвращает значение из поля prop, тогда как аксессор set устанавливает зна­
чение в поле prop в том и только в том случае, если это значение оказывается поло­
жительным. Таким образом, свойство MyProp контролирует значения, которые могут
храниться в поле prop. В этом, собственно, и состоит основное назначение свойств.

Тип свойства MyProp определяется как для чтения, так и для записи, поскольку оно
позволяет читать и записывать данные в базовое поле. Тем не менее свойства можно
создавать доступными только для чтения или только для записи. Так, если требуется
создать свойство, доступное только для чтения, то достаточно определить единствен­
ный аксессор get. А если нужно создать свойство, доступное только для записи, то
достаточно определить единственный аксессор set.

Воспользуемся свойством для дальнейшего усовершенствования отказоустойчивого
массива. Как вам должно быть уже известно, у всех массивов имеется соответствую­
щее свойство длины (Length). До сих пор в классе FailSoftArray для этой цели ис­
пользовалось открытое целочисленное поле Length. Но это далеко не самый лучший
подход, поскольку он допускает установку значений, отличающихся от длины отказоу­
стойчивого массива. (Например, программист, преследующий злонамеренные цели,
может умышленно ввести неверное значение в данном поле.) Для того чтобы испра­
вить это положение, превратим поле Length в свойство "только для чтения", как по­
казано в приведенном ниже, измененном варианте класса FailSoftArray.
```
// Добавить свойство Length в класс FailSoftArray.
using System;

class FailSoftArray {
    int[] a; // ссылка на базовый массив
    int len; // длина массива — служит основанием для свойства Length
    public bool ErrFlag; // обозначает результат последней операции
    // Построить массив заданного размера.
    public FailSoftArray(int size) {
        a = new int[size];
        len = size;
    }
    // Свойство Length только для чтения.
    public int Length {
        get {
            return len;
        }
    }
    // Это индексатор для класса FailSoftArray.
    public int this[int index] {
        // Это аксессор get.
        get {
            if(ok(index)) {
                ErrFlag = false;
                return a[index];
            } else {
                ErrFlag = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            if(ok(index)) {
                a [index] = value;
                ErrFlag = false;
            }
            else ErrFlag = true;
        }
    }
    // Возвратить логическое значение true, если
    // индекс находится в установленных границах.
    private bool ok(int index) {
        if(index >= 0 & index < Length) return true;
        return false;
    }
}

// Продемонстрировать применение усовершенствованного
// отказоустойчивого массива.
class ImprovedFSDemo {
    static void Main() {
        FailSoftArray fs = new FailSoftArray(5);
        int x;
        // Разрешить чтение свойства Length.
        for(int i=0; i < fs.Length; i++)
            fs[i] = i*10;
        for(int i=0; i < fs.Length; i++) {
            x = fs[i];
            if(x != -1) Console.Write(x + " ");
        }
        Console.WriteLine();
        // fs.Length = 10; // Ошибка, запись запрещена!
    }
}
```
Теперь Length — это свойство, в котором местом для хранения данных служит
закрытая переменная len. А поскольку в этом свойстве определен единственный ак-
ceccop get, то оно доступно только для чтения. Это означает, что значение свойства
Length можно только читать, но не изменять. Для того чтобы убедиться в этом, по­
пробуйте удалить символы комментария в начале следующей строки из приведенного
выше кода.
```
// fs.Length = 10; // Ошибка, запись запрещена!
```
При попытке скомпилировать данный код вы получите сообщение об ошибке,
уведомляющее о том, что Length является свойством, доступным только для чтения.

Добавлением свойства Length в класс FailSoftArray усовершенствование рас­
сматриваемого здесь примера кода с помощью свойств далеко не исчерпывается. Еще
одним членом данного класса, подходящим для превращения в свойство, служит пере­
менная ErrFlag, поскольку ее применение должно быть ограничено только чтением.
Ниже приведен окончательно усовершенствованный вариант класса FailSoftArray,
в котором создается свойство Error, использующее в качестве места для хранения дан­
ных исходную переменную ErrFlag, ставшую теперь закрытой.
```
// Превратить переменную ErrFlag в свойство.
using System;

class FailSoftArray {
    int[] a; // ссылка на базовый массив
    int len; // длина массива
    bool ErrFlag; // теперь это частная переменная,
    // обозначающая результат последней операции
    // Построить массив заданного размера.
    public FailSoftArray(int size) {
        a = new int[size];
        len = size;
    }
    // Свойство Length только для чтения.
    public int Length {
        get {
            return len;
        }
    }
    // Свойство Error только для чтения.
    public bool Error {
        get {
            return ErrFlag;
        }
    }
    // Это индексатор для класса FailSoftArray.
    public int this[int index] {
        // Это аксессор get.
        get {
            if(ok(index)) {
                ErrFlag = false;
                return a[index];
            } else {
                ErrFlag = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            if(ok(index)) {
                a[index] = value;
                ErrFlag = false;
            }
            else ErrFlag = true;
        }
    }
    // Возвратить логическое значение true, если
    // индекс находится в установленных границах.
    private bool ok(int index) {
        if(index >= 0 & index < Length) return true;
        return false;
    }
}

// Продемонстрировать применение отказоустойчивого массива.
class FinalFSDemo {
    static void Main() {
        FailSoftArray fs = new FailSoftArray(5);
        // Использовать свойство Error.
        for(int i=0; i < fs.Length + 1; i++) {
            fs[i] = i*10;
            if(fs.Error)
                console.WriteLine("Ошибка в индексе " + i);
        }
    }
}
```
Создание свойства Error стало причиной двух следующих изменений в классе
FailSoftArray. Во-первых, переменная ErrFlag была сделана закрытой, посколь­
ку теперь она служит базовым местом хранения данных для свойства Error, а следо­
вательно, она не должна быть доступна непосредственно. И во-вторых, было введено
свойство Error "только для чтения". Теперь свойство Error будет опрашиваться в тех
программах, где требуется организовать обнаружение ошибок. Именно это и было
продемонстрировано выше в методе Main(), где намеренно сгенерирована ошибка
нарушения границ массива, а для ее обнаружения использовано свойство Error.

### Автоматически реализуемые свойства
Начиная с версии C# 3.0, появилась возможность для реализации очень простых
свойств, не прибегая к явному определению переменной, которой управляет свойство.
Вместо этого базовую переменную для свойства автоматически предоставляет компи­
лятор. Такое свойство называется автоматически реализуемым и принимает следую­
щую общую форму:
```
тип имя { get; set; }
```
где тип обозначает конкретный тип свойства, а имя — присваиваемое свойству имя.
Обратите внимание на то, что после обозначений аксессоров get и set сразу же сле­
дует точка с запятой, а тело у них отсутствует. Такой синтаксис предписывает компиля­
тору создать автоматически переменную, иногда еще называемую поддерживающим по­
лем, для хранения значения. Такая переменная недоступна непосредственно и не имеет
имени. Но в то же время она может быть доступна через свойство.

Ниже приведен пример объявления свойства, автоматически реализуемого под
именем UserCount.
```
public int UserCount { get; set; }
```
Как видите, в этой строке кода переменная явно не объявляется. И как пояснялось
выше, компилятор автоматически создает анонимное поле, в котором хранится зна­
чение. А в остальном автоматически реализуемое свойство UserCount подобно всем
остальным свойствам.

Но в отличие от обычных свойств автоматически реализуемое свойство не может
быть доступным только для чтения или только для записи. При объявлении этого свой­
ства в любом случае необходимо указывать оба аксессора — get и set. Хотя добиться
желаемого (т.е. сделать автоматически реализуемое свойство доступным только для
чтения или только для записи) все же можно, объявив ненужный аксессор как private
(подробнее об этом — в разделе "Применение модификаторов доступа в аксессорах").

Несмотря на очевидные удобства автоматически реализуемых свойств, их примене­
ние ограничивается в основном теми ситуациями, в которых не требуется управление
установкой или получением значений из поддерживающих полей. Напомним, что
поддерживающее поле недоступно напрямую. Это означает, что на значение, которое
может иметь автоматически реализуемое свойство, нельзя наложить никаких ограни­
чений. Следовательно, имена автоматически реализуемых свойств просто заменяют
собой имена самих полей, а зачастую именно это и требуется в программе. Автомати­
чески реализуемые свойства могут оказаться полезными и в тех случаях, когда с помо­
щью свойств функциональные возможности программы открываются для сторонних
пользователей, и для этой цели могут даже применяться специальные средства про­
ектирования.

### Применение инициализаторов объектов в свойствах
Как пояснялось в главе 8, инициализатор объекта применяется в качестве альтерна­
тивы явному вызову конструктора при создании объекта. С помощью инициализато­
ров объектов задаются начальные значения полей или свойств, которые требуется ини­
циализировать. При этом синтаксис инициализаторов объектов оказывается одинако­
вым как для свойств, так и для полей. В качестве примера ниже приведена программа
из главы 8, измененная с целью продемонстрировать применение инициализаторов
объектов в свойствах. Напомним, что в версии этой программы из главы 8 использо­
вались поля, а приведенная ниже версия отличается лишь тем, что в ней поля Count
и Str превращены в свойства. В то же время синтаксис инициализаторов объектов не
изменился.
```
// Применить инициализаторы объектов в свойствах.
using System;

class MyClass {
    // Теперь это свойства.
    public int Count { get; set; }
    public string Str { get; set; }
}

class ObjInitDemo {
    static void Main() {
        // Сконструировать объект типа MyClass с помощью инициализаторов
        объектов.
        MyClass obj =
            new MyClass { Count = 100, Str = "Тестирование" };
        Console.WriteLine(obj.Count + " " + obj.Str);
    }
}
```
Как видите, свойства Count и Str устанавливаются в выражениях с инициализато­
ром объекта. Приведенная выше программа дает такой же результат, как и программа
из главы 8, а именно:
```
100 Тестирование
```
Как пояснялось в главе 8, синтаксис инициализатора объекта оказывается наиболее
пригодным для работы с анонимными типами, формируемыми в LINQ-выражениях.
А в остальных случаях чаще всего используется синтаксис обычных конструкторов.

### Ограничения, присущие свойствам
Свойствам присущ ряд существенных ограничений. Во-первых, свойство не опреде­
ляет место для хранения данных, и поэтому не может быть передано методу в качестве
параметра ref или out. Во-вторых, свойство не подлежит перегрузке. Наличие двух
разных свойств с доступом к одной и той же переменной допускается, но это, скорее,
исключение, чем правило. И наконец, свойство не должно изменять состояние базо­
вой переменной при вызове аксессора get. И хотя это ограничительное правило не
соблюдается компилятором, его нарушение считается семантической ошибкой. Дей­
ствие аксессора get не должно носить характер вмешательства в функционирование
переменной.

## Применение модификаторов доступа в аксессорах
По умолчанию доступность аксессоров set и get оказывается такой же, как и у
индексатора и свойства, частью которых они являются. Так, если свойство объявляется
как public, то по умолчанию его аксессоры set и get также становятся открытыми
(public). Тем не менее для аксессора set или get можно указать собственный мо­
дификатор доступа, например private. Но в любом случае доступность аксессора,
определяемая таким модификатором, должна быть более ограниченной, чем доступ­
ность, указываемая для его свойства или индексатора.

Существует целый ряд причин, по которым требуется ограничить доступность ак­
сессора. Допустим, что требуется предоставить свободный доступ к значению свойства,
но вместе с тем дать возможность устанавливать это свойство только членам его класса.
Для этого достаточно объявить аксессор данного свойства как private. В приведен­
ном ниже примере используется свойство MyProp, аксессор set которого указан как
private.
```
// Применить модификатор доступа в аксессоре.
using System;

class PropAccess {
    int prop; // поле, управляемое свойством МуРrор
    public PropAccess() { prop = 0; }
    /* Это свойство обеспечивает доступ к закрытой переменной экземпляра prop.
    Оно разрешает получать значение переменной prop из любого кода,
    но устанавливать его — только членам своего класса. */
    public int МуРrор {
        get {
            return prop;
        }
        private set { // теперь это закрытый аксессор
            prop = value;
        }
    }
    // Этот член класса инкрементирует значение свойства МуРrор.
    public void IncrProp() {
        MyProp++; // Допускается в. том же самом классе.
    }
}

// Продемонстрировать применение модификатора доступа в аксессоре свойства.
class PropAccessDemo {
    static void Main() {
        PropAccess ob = new PropAccess();
        Console.WriteLine("Первоначальное значение ob.МуРrор: " + ob.МуРrор);
        // ob.МуРrор = 100; // недоступно для установки
        ob.IncrProp();
        Console.WriteLine("Значение ob.МуРrор после инкрементирования: " +
                        ob.МуРrор);
    }
}
```
В классе PropAccess аксессор set указан как private. Это означает, что он досту­
пен только другим членам данного класса, например методу IncrProp(), но недосту­
пен для кода за пределами класса PropAccess. Именно поэтому попытка Присвоить
свойству ob.МуРrор значение в классе PropAccessDemo закомментирована.

Вероятно, ограничение доступа к аксессорам оказывается наиболее важным для
работы с автоматически реализуемыми свойствами. Как пояснялось выше, создать
автоматически реализуемое свойство только для чтения или же только для записи
нельзя, поскольку оба аксессора, get и set, должны быть указаны при объявлении
такого свойства. Тем не менее добиться желаемого результата все же можно, объявив
один из аксессоров автоматически реализуемого свойства как private. В качестве
примера ниже приведено объявление автоматически реализуемого свойства Length
для класса FailSoftArray, которое фактически становится доступным только для
чтения.
```
public int Length { get; private set; }
```
Свойство Length может быть установлено только из кода в его классе, поскольку
его аксессор set объявлен как private. А изменять свойство Length за пределами
его класса не разрешается. Это означает, что за пределами своего класса свойство, по
существу, оказывается доступным только для чтения. Аналогичным образом можно
объявить и свойство Error, как показано ниже.
```
public bool Error { get; private set; }
```
Благодаря этому свойство Error становится доступным для чтения, но не для уста­
новки за пределами класса FailSoftArray.

Для опробования автоматически реализуемых вариантов свойств Length и Error
в классе FailSoftArray удалим сначала переменные len и ErrFlag, поскольку они
больше не нужны, а затем заменим каждое применение переменных len и ErrFlag
свойствами Length и Error в классе FailSoftArray. Ниже приведен обновленный
вариант класса FailSoftArray вместе с методом Main(), демонстрирующим его
применение.
```
// Применить автоматически реализуемые и доступные
// только для чтения свойства Length и Error.
using System;

class FailSoftArray {
    int[] a; // ссылка на базовый массив
    // Построить массив по заданному размеру.
    public FailSoftArray(int size) {
        a = new int [size];
        Length = size;
    }
    // Автоматически реализуемое и доступное только для чтения свойство Length.
    public int Length { get; private set; }
    // Автоматически реализуемое и доступное только для чтения свойство Error.
    public bool Error { get; private set; }
    // Это индексатор для массива FailSoftArray.
    public int this[int index] {
        // Это аксессор get.
        get {
            if(ok(index)) {
                Error = false;
                return a[index];
            } else {
                Error = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            if(ok(index)) {
                a[index] = value;
                Error = false;
            }
            else Error = true;
        }
    }
    // Возвратить логическое значение true, если
    // индекс находится в установленных границах.
    private bool ok(int index) {
        if(index >= 0 & index < Length) return true;
        return false;
    }
}

// Продемонстрировать применение усовершенствованного
// отказоустойчивого массива.
class FinalFSDemo {
    static void Main() {
        FailSoftArray fs = new FailSoftArray(5);
        // Использовать свойство Error.
        for(int i=0; i < fs.Length + 1; i++) {
            fs[i] = i*10;
            if(fs.Error)
                Console.WriteLine("Ошибка в индексе " + i);
        }
    }
}
```
Этот вариант класса FailSoftArray действует таким же образом, как и предыду­
щий, но в нем отсутствуют поддерживающие поля, объявляемые явно.

На применение модификаторов доступа в аксессорах накладываются следующие
ограничения. Во-первых, действию модификатора доступа подлежит только один ак­
сессор: set или get, но не оба сразу. Во-вторых, модификатор должен обеспечивать
более ограниченный доступ к аксессору, чем доступ на уровне свойства или индексато­
ра. И наконец, модификатор доступа нельзя использовать при объявлении аксессора
в интерфейсе или же при реализации аксессора, указываемого в интерфейсе. (Подроб­
нее об интерфейсах речь пойдет в главе 12.)

## Применение индексаторов и свойств
В предыдущих примерах программ был продемонстрирован основной принцип
действия индексаторов и свойств, но их возможности не были раскрыты в полную
силу. Поэтому в завершение этой главы обратимся к примеру класса RangeArray,
в котором индексаторы и свойства используются для создания типа массива с преде­
лами индексирования, определяемыми пользователем.

Как вам должно быть уже известно, индексирование всех массивов в C# начинается
с нуля. Но в некоторых приложениях индексирование массива удобнее начинать с лю­
бой произвольной точки отсчета: с 1 или даже с отрицательного числа, например от
-5 и до 5. Рассматриваемый здесь класс RangeArray разработан таким образом, чтобы
допускать подобного рода индексирование массивов.

Используя класс RangeArray, можно написать следующий фрагмент кода.
```
RangeArray rа = new RangeArray(-5, 10); // массив с индексами от -5 до 10
for(int i=-5; i <= 10; i++) ra[i] = i; // индексирование массива от -5 до 10
```
Нетрудно догадаться, что в первой строке этого кода конструируется объект клас­
са RangeArray с пределами индексирования массива от -5 до 10 включительно. Пер­
вый аргумент обозначает начальный индекс, а второй — конечный индекс. Как только
объект rа будет сконструирован, он может быть проиндексирован как массив в преде­
лах от -5 до 10.

Ниже приведен полностью класс RangeArray вместе с классом RangeArrayDemo,
в котором демонстрируется индексирование массива в заданных пределах. Класс
RangeArray реализован таким образом, чтобы поддерживать массивы типа int, но
при желании вы можете изменить этот тип на любой другой.
```
/* Создать класс со специально указываемыми пределами индексирования массива.
    Класс RangeArray допускает индексирование массива с любого значения, а не
    только с нуля. При создании объекта класса RangeArray указываются начальный
    и конечный индексы. Допускается также указывать отрицательные индексы.
    Например, можно создать массивы, индексируемые от -5 до 5, от 1 до 10
    или же от 50 до 56. */
using System;

class RangeArray {
    // Закрытые данные.
    int[] а; // ссылка на базовый массив
    int lowerBound; // наименьший индекс
    int upperBound; // наибольший индекс
    // Автоматически реализуемое и доступное только для чтения свойство Length.
    public int Length { get; private set; }
    // Автоматически реализуемое и доступное только для чтения свойство Error.
    public bool Error { get; private set; }
    // Построить массив по заданному размеру.
    public RangeArray(int low, int high) {
        high++;
        if(high <= low) {
            Console.WriteLine("Неверные индексы");
            high = 1; // создать для надежности минимально допустимый массив
            low = 0;
        }
        а = new int[high - low];
        Length = high - low;
        lowerBound = low;
        upperBound = --high;
    }

    // Это индексатор для класса RangeArray.
    public int this[int index] {
        // Это аксессор get.
        get {
            if(ok(index)) {
                Error = false;
                return a[index - lowerBound];
            } else {
                Error = true;
                return 0;
            }
        }
        // Это аксессор set.
        set {
            if(ok(index)) {
                a[index - lowerBound] = value;
                Error = false;
            }
            else Error = true;
        }
    }

    // Возвратить логическое значение true, если
    // индекс находится в установленных границах.
    private bool ok(int index) {
        if(index >= lowerBound & index <= upperBound) return true;
        return false;
    }
}

// Продемонстрировать применение массива с произвольно
// задаваемыми пределами индексирования.
class RangeArrayDemo {
    static void Main() {
        RangeArray ra = new RangeArray(-5, 5);
        RangeArray ra2 = new RangeArray(1, 10);
        RangeArray ra3 = new RangeArray(-20, -12);
        // Использовать объект ra в качестве массива.
        Console.WriteLine("Длина массива ra: " + rа.Length);
        for(int i = -5; i <= 5; i++)
        ra[i] = i;
        Console.Write("Содержимое массива ra: ");
        for(int i = -5; i <= 5; i++)
        Console.Write(ra[i] + " ");
        Console.WriteLine("\n");

        // Использовать объект ra2 в качестве массива.
        Console.WriteLine("Длина массива ra2: " + ra2.Length);
        for(int i = 1; i <= 10; i++)
        ra2[i] = i;
        Console.Write("Содержимое массива ra2: ");
        for(int i = 1; i <= 10; i++)
        Console.Write(ra2[i] + " ");
        Console.WriteLine("\n");

        // Использовать объект raЗ в качестве массива.
        Console.WriteLine("Длина массива ra3: " + ra3.Length);
        for(int i = -20; i <= -12; i++)
        ra3[i] = i;
        Console.Write("Содержимое массива ra3: ");
        for(int i = -20; i <= -12; i++)
        Console.Write(ra3[i] + " ");
        Console.WriteLine("\n");
    }
}
```
При выполнении этого кода получается следующий результат.
```
Длина массива ra: 11
Содержимое массива ra: -5 -4 -3 -2 -1 0 1 2 3 4 5

Длина массива ra2: 10
Содержимое массива ra2: 1 2 3 4 5 6 7 8 9 10

Длина массива ra3: 9
Содержимое массива ra2: -20 -19 -18 -17 -16 -15 -14 -13 -12
```
Как следует из результата выполнения приведенного выше кода, объекты типа
RangeArray можно индексировать в качестве массивов, начиная с любой точ­
ки отсчета, а не только с нуля. Рассмотрим подробнее саму реализацию класса
RangeArray.

В начале класса RangeArray объявляются следующие закрытые переменные эк­
земпляра.
```
// Закрытые данные.
int[] а; // ссылка на базовый массив
int lowerBound; // наименьший индекс
int upperBound; // наибольший индекс
```
Переменная а служит для обращения к базовому массиву по ссылке. Память для
него распределяется конструктором класса RangeArray. Нижняя граница индексиро­
вания массива хранится в переменной lowerBound, а верхняя граница — в перемен­
ной upperBound.
```
Далее объявляются автоматически реализуемые свойства Length и Error.
```
// Автоматически реализуемое и доступное только для чтения свойство Length.
public int Length { get; private set; }
// Автоматически реализуемое и доступное только для чтения свойство Error.
public bool Error { get; private set; }
```
Обратите внимание на то, что в обоих свойства аксессор set обозначен как private.
Как пояснялось выше, такое объявление автоматически реализуемого свойства, по су­
ществу, делает его доступным только для чтения.

Ниже приведен конструктор класса RangeArray.
```
// Построить массив по заданному размеру.
public RangeArray(int low, int high) {
    high++;
    if(high <= low) {
        Console.WriteLine("Неверные индексы");
        high = 1; // создать для надежности минимально допустимый массив
        low = 0;
    }
    а = new int[high - low];
    Length = high - low;
    lowerBound = low;
    upperBound = --high;
}
```
При конструировании объекту класса RangeArray передается нижняя граница
массива в качестве параметра low, а верхняя граница — в качестве параметра high.
Затем значение параметра high инкрементируется, поскольку пределы индексирова­
ния массива изменяются от low до high включительно. Далее выполняется следующая
проверка: является ли верхний индекс больше нижнего индекса. Если это не так, то
выдается сообщение об ошибке и создается массив, состоящий из одного элемента.
После этого для массива распределяется память, а ссылка на него присваивается пере­
менной а. Затем свойство Length устанавливается равным числу элементов массива.
И наконец, устанавливаются переменные lowerBound и upperBound.

Далее в классе RangeArray реализуется его индексатор, как показано ниже.
```
// Это индексатор для класса RangeArray.
public int this[int index] {
    // Это аксессор get.
    get {
        if(ok(index)) {
            Error = false;
            return a[index - lowerBound];
        } else {
            Error = true;
            return 0;
        }
    }
    // Это аксессор set.
    set {
        if(ok(index)) {
            a[index - lowerBound] = value;
            Error = false;
        }
        else Error = true;
    }
}
```
Этот индексатор подобен тому, что использовался в классе FailSoftArray, за од­
ним существенным исключением. Обратите внимание на следующее выражение, в ко­
тором индексируется массив а.
```
index - lowerBound
```
В этом выражении индекс, передаваемый в качестве параметра index, преобразу­
ется в индекс с отсчетом от нуля, пригодный для индексирования массива а. Данное
выражение действует при любом значении переменной lowerBound: положительном,
отрицательном или нулевом.

Ниже приведен метод ok().
```
// Возвратить логическое значение true, если
// индекс находится в установленных границах.
private bool ok(int index) {
    if(index >= lowerBound & index <= upperBound) return true;
    return false;
}
```
Этот метод аналогичен использовавшемуся в классе FailSoftArray, за исключе­
нием того, что в нем контроль границ массива осуществляется по значениям перемен­
ных lowerBound и upperBound.

Класс RangeArray демонстрирует лишь одну разновидность специализированного
массива, который может быть создан с помощью индексаторов и свойств. Существу­
ют, конечно, и другие. Аналогичным образом можно, например, создать динамиче­
ские массивы, которые расширяются или сужаются по мере надобности, ассоциатив­
ные и разреженные массивы. Попробуйте создать один из таких массивов в качестве
упражнения.