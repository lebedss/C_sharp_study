# ГЛАВА 16. Пространства имен, препроцессор и сборки
В этой главе речь пойдет о трех средствах С#, позволяю­
щих улучшить организованность и доступность про­
граммы. Этими средствами являются пространства
имен, препроцессор и сборки.

## Пространства имен
О пространстве имен уже вкратце упоминалось в главе 2
в связи с тем, что это основополагающее понятие для С#.
В действительности пространство имен в той или иной сте­
пени используется в каждой программе на С#. Потребность
в подробном рассмотрении пространств имен не возникала
до сих пор потому, что для каждой программы на C# авто­
матически предоставляется используемое по умолчанию
глобальное пространство имен. Следовательно, в приме­
рах программ, представленных в предыдущих главах, ис­
пользовалось глобальное пространство имен. Но во многих
реальных программах приходится создавать собственные
пространства имен или же организовать взаимодействие
с другими пространствами имен. Подобные пространства
будут представлены далее во всех подробностях.

Пространство имен определяет область объявлений,
в которой допускается хранить одно множество имен от­
дельно от другого. По существу, имена, объявленные
в одном пространстве имен, не будут вступать в конфликт
с аналогичными именами, объявленными в другой обла­
сти. Так, в библиотеке классов для среды .NET Framework,
которая одновременно является библиотекой классов С#,
используется пространство имен System. Именно поэтому
строка кода
```
using System;
```
обычно вводится в самом начале любой программы на С#. Как пояснялось в главе 14,
классы ввода-вывода определены в пространстве имен System.IO, подчиненном про­
странству имен System. Ему подчинены и многие другие пространства имен, относя­
щиеся к разным частям библиотеки классов С#.

Пространства имен важны потому, что за последние годы в программировании
"расплодились" в огромном количестве имена переменных, методов, свойств и клас­
сов, применяемых в библиотечных программах, стороннем и собственном коде. Поэто­
му без отдельных пространств все эти имена будут соперничать за место в глобальном
пространстве имен, порождая конфликтные ситуации. Так, если в программе опреде­
лен класс Finder, то этот класс может вступить в конфликт с другим классом Finder,
доступным в сторонней библиотеке, используемой в этой программе. К счастью, по­
добного конфликта можно избежать, используя отдельные пространства имен, огра­
ничивающие область видимости объявленных в них имен.

### Объявление пространства имен
Пространство имен объявляется с помощью ключевого слова namespace. Ниже
приведена общая форма объявления пространства имен:
```
namespace имя {
    // члены
}
```
где имя обозначает конкретное имя объявляемого пространства имен. При объявлении
пространства имен определяется область его действия. Все, что объявляется непосред­
ственно в этом пространстве, оказывается в пределах его области действия. В простран­
стве имен можно объявить классы, структуры, делегаты, перечисления, интерфейсы
или другие пространства имен.

Ниже приведен пример объявления namespace для создания пространства имен
Counter. В этом пространстве локализуется имя, используемое для реализации про­
стого класса вычитающего счетчика CountDown.
```
// Объявить пространство имен для счетчиков.
namespace Counter {
    // Простой вычитающий счетчик.
    class CountDown {
        int val;
        public CountDown(int n) {
            val = n;
        }

        public void Reset(int n) {
            val = n;
        }

        public int Count() {
            if(val > 0) return val--;
            else return 0;
        }
    }
} // Это конец пространства имен Counter.
```
Обратите внимание на то, что класс CountDown объявляется в пределах области
действия пространства имен Counter. Для того чтобы проработать этот пример на
практике, поместите приведенный выше код в файл Counter.cs.

Ниже приведен пример программы, демонстрирующий применение пространства
имен Counter.
```
// Продемонстрировать применение пространства имен Counter.
using System;

class NSDemo {
    static void Main() {
        // Обратите внимание на то, как класс CountDown
        // определяется с помощью пространства имен Counter.
        Counter.CountDown cd1 = new Counter.CountDown(10);
        int i;
        do {
            i = cd1.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        // Еще раз обратите внимание на то, как класс CountDown
        // определяется с помощью пространства имен Counter.
        Counter.CountDown cd2 = new Counter.CountDown(20);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        cd2.Reset(4);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
    }
}
```
При выполнении этой программы получается следующий результат.
```
10 9 8 7 6 5 4 3 2 1 0
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4 3 2 1 0
```
Для того чтобы скомпилировать эту программу, вы должны включить приве­
денный выше код в отдельный файл и указать его вместе с упоминавшимся выше
файлом, содержащим код объявления пространства имен Counter. Если этот код
находится в файле NSDemo.cs, а код объявления пространства имен Counter — в фай­
ле Counter.cs, то для компиляции программы используется следующая командная
строка.
```
csc NSDemo.cs counter.cs
```
Некоторые важные аспекты данной программы заслуживают более пристального
внимания. Во-первых, при создании объекта класса CountDown необходимо допол­
нительно определить его имя с помощью пространства имен Counter, как показано
ниже. Ведь класс CountDown объявлен в пространстве имен Counter.
```
Counter.CountDown cd1 = new Counter.CountDown(10);
```
Это правило можно обобщить: всякий раз, когда используется член пространства
имен, его имя необходимо дополнительно определить с помощью этого пространства
имен. В противном случае член пространства имен не будет обнаружен компилятором.

Во-вторых, как только объект типа Counter будет создан, дополнительно опреде­
лять его члены с помощью пространства имен уже не придется. Следовательно, метод
cd1.Count() может быть вызван непосредственно без дополнительного указания про­
странства имен, как в приведенной ниже строке кода.
```
i = cd1.Count();
```
И в-третьих, ради наглядности примера рассматриваемая здесь программа была
разделена на два отдельных файла. В одном файле содержится код объявления про­
странства имен Counter, а в другом — код самой программы NSDemo. Но оба фраг­
мента кода можно было бы объединить в единый файл. Более того, в одном файле ис­
ходного кода может содержаться два или более пространства имен со своими собствен­
ными областями объявлений. Когда оканчивается действие внутреннего пространства
имен, возобновляется действие внешнего пространства имен — в примере с Counter
это глобальное пространство имен. Ради большей ясности в последующих примерах
все пространства имен, требующиеся в программе, будут представлены в одном и том
же файле. Следует, однако, иметь в виду, что их допускается распределять по отдель­
ным файлам, что практикуется чаще в выходном коде.

### Предотвращение конфликтов имен с помощью пространств имен
Главное преимущество пространств имен заключается в том, что объявленные в них
имена не вступают в конфликт с именами, объявленными за их пределами. Например,
в приведенной ниже программе определяются два пространства имен. Первым из них
является представленное ранее пространство имен Counter, а вторым — Counter2.
Оба пространства имен содержат классы с одинаковым именем CountDown, но по­
скольку это разные пространства, то оба класса CountDown не вступают в конфликт
друг с другом. Кроме того, оба пространства имен определены в одном и том же фай­
ле. Как пояснялось выше, это вполне допустимо. Безусловно, каждое из этих про­
странств имен можно было бы выделить в отдельный файл, если бы в этом возникла
потребность.
```
// Пространства имен предотвращают конфликты имен.
using System;

// Объявить пространство имен Counter.
namespace Counter {
    // Простой вычитающий счетчик.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        public void Reset(int n) {
            val = n;
        }

        public int Count() {
            if(val > 0) return val--;
            else return 0;
        }
    }
}

// Объявить пространство имен Counter2.
namespace Counter2 {
    /* Этот класс CountDown относится к пространству
        имен Counter2 и поэтому не вступает в конфликт
        с аналогичным классом из пространства имен Counter.
    */
    class CountDown {
        public void Count() {
            Console.WriteLine("Это метод Count() из " +
                            "пространства имен Counter2.");
        }
    }
}

class NSDemo2 {
    static void Main() {
        // Это класс CountDown из пространства имен Counter.
        Counter.CountDown cd1 = new Counter.CountDown(10);

        // Это класс CountDown из пространства имен Counter2.
        Counter2.CountDown cd2 = new Counter2.CountDown();

        int i;
        do {
            i = cd1.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        cd2.Count();
    }
}
```
Вот к какому результату приводит выполнение этой программы.
```
10 9 8 7 6 5 4 3 2 1 0
Это метод Count() из пространства имен Counter2.
```
Как следует из приведенного выше результата, класс CountDown из пространства
имен Counter существует отдельно от класса того же названия из пространства имен
Counter2, и поэтому конфликт имен не возникает. Несмотря на всю простоту данного
примера, он наглядно показывает, как удается избежать конфликта имен в собствен­
ном коде и коде, написанном другими разработчиками, поместив классы с одинаковы­
ми именами в разные пространства имен.

### Директива using
Если в программе присутствуют частые ссылки на члены конкретного пространства
имен, то указывать это пространство всякий раз, когда требуется ссылка на него, не
очень удобно. Преодолеть это затруднение помогает директива using. В подавляю­
щем большинстве приводившихся ранее примеров программ с помощью этой ди­
рективы делалось видимым глобальное для C# пространство имен System, поэтому
она отчасти вам уже знакома. Как и следовало ожидать, с помощью директивы using
можно сделать видимыми вновь создаваемые пространства имен.

Существуют две формы директивы using. Ниже приведена первая из них:
```
using имя;
```
где имя обозначает имя того пространства имен, к которому требуется получить до­
ступ. Все члены, определенные в указанном пространстве имен, становятся видимы­
ми, и поэтому могут быть использованы без дополнительного определения их имен.
Директиву using необходимо вводить в самом начале каждого файла исходного кода
перед любыми другими объявлениями или же в начале тела пространства имен.

Приведенная ниже программа является вариантом предыдущего примера, пере­
работанным с целью продемонстрировать применение директивы using, делающей
видимым создаваемое пространство имен.
```
// Продемонстрировать применение директивы using.
using System;

// Сделать видимым пространство имен Counter.
using Counter;

// Объявить пространство имен для счетчиков.
namespace Counter {
    // Простой вычитающий счетчик.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        public void Reset(int n) {
            val = n;
        }

        public int Count() {
            if(val > 0) return val--;
            else return 0;
        }
    }
}

class NSDemo3 {
    static void Main() {
        // Теперь класс CountDown может быть использован непосредственно.
        CountDown cd1 = new CountDown(10);
        int i;
        do {
            i = cd1.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        CountDown cd2 = new CountDown(20);

        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        cd2.Reset(4);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
    }
}
```
В эту версию программы внесены два существенных изменения. Первое из них
состоит в применении директивы using в самом начале программы, как показано
ниже.
```
using Counter;
```
Благодаря этому становится видимым пространство имен Counter. Второе измене­
ние состоит в том, что класс CountDown больше не нужно дополнительно определять с
помощью пространства имен Counter, как демонстрирует приведенная ниже строка
кода из метода Main().
```
CountDown cd1 = new CountDown(10);
```
Теперь пространство имен Counter становится видимым, и поэтому класс
CountDown может быть использован непосредственно.

Рассматриваемая здесь программа иллюстрирует еще одно важное обстоятельство:
применение одного пространства имен не отменяет действие другого. Когда простран­
ство имен делается видимым, это просто дает возможность использовать его содержи­
мое без дополнительного определения имен. Следовательно, в данном примере оба
пространства имен, System и Counter, становятся видимыми.

### Вторая форма директивы using
Вторая форма директивы using позволяет определить еще одно имя (так называе­
мый псевдоним) типа данных или пространства имен. Эта форма приведена ниже:
```
using псевдоним = имя;
```
где псевдоним становится еще одним именем типа (например, типа класса) или про­
странства имен, обозначаемого как имя. После того как псевдоним будет создан, он
может быть использован вместо первоначального имени.

Ниже приведен вариант программы из предыдущего примера, измененный с це­
лью показать создание и применение псевдонима MyCounter вместо составного имени
Counter.CountDown.
```
// Продемонстрировать применение псевдонима.
using System;

// Создать псевдоним для составного имени Counter.CountDown.
using MyCounter = Counter.CountDown;

// Объявить пространство имен для счетчиков.
namespace Counter {
    // Простой вычитающий счетчик.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        public void Reset(int n) {
            val = n;
        }

        public int Count() {
            if(val > 0) return val--;
            else return 0;
        }
    }
}

class NSDemo4 {
    static void Main() {
        // Здесь и далее псевдоним MyCounter используется
        // вместо составного имени Counter.CountDown.
        MyCounter cd1 = new MyCounter(10);
        int i;
        do {
            i = cd1.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        MyCounter cd2 = new MyCounter(20);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        cd2.Reset(4);
        do {
            i = cd2.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();
    }
}
```
Псевдоним MyCounter создается с помощью следующего оператора.
```
using MyCounter = Counter.CountDown;
```
После того как псевдоним будет определен в качестве другого имени класса
Counter.CountDown, его можно использовать для объявления объектов без дополни­
тельного определения имени данного класса. Например, в следующей строке кода из
рассматриваемой здесь программы создается объект класса CountDown.
```
MyCounter cd1 = new MyCounter(10);
```

### Аддитивный характер пространств имен
Под одним именем можно объявить несколько пространств имен. Это дает воз­
можность распределить пространство имен по нескольким файлам или даже разде­
лить его в пределах одного и того же файла исходного кода. Например, в приведенной
ниже программе два пространства имен определяются под одним и тем же именем
Counter. Одно из них содержит класс CountDown, а другое — класс CountUp. Во вре­
мя компиляции содержимое обоих пространств имен Counter складывается.
```
// Аддитивный характер пространств имен.
using System;

// Сделать видимым пространство имен Counter.
using Counter;

// Это одно пространство имен Counter.
namespace Counter {
    // Простой вычитающий счетчик.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        public void Reset(int n) {
            val = n;
        }

        public int Count() {
            if(val > 0) return val--;
            else return 0;
        }
    }
}

// А это другое пространство имен Counter.
namespace Counter {
    // Простой суммирующий счетчик.
    class CountUp {
        int val;
        int target;

        public int Target {
            get{
                return target;
            }
        }

        public CountUp(int n) {
            target = n;
            va1 = 0;
        }

        public void Reset(int n) {
            target = n;
            val = 0;
        }

        public int Count() {
            if(val < target) return val++;
            else return target;
        }
    }
}

class NSDemo5 {
    static void Main() {
        CountDown cd = new CountDown(10);
        CountUp cu = new CountUp(8);

        int i;
        do {
            i = cd.Count();
            Console.Write(i + " ");
        } while(i > 0);
        Console.WriteLine();

        do {
            i = cu.Count();
            Console.Write(i + " ");
        } while(d < cu.Target);
    }
}
```
Вот к какому результату приводит выполнение этой программы.
```
10 9 8 7 6 5 4 3 2 1 0
0 1 2 3 4 5 6 7 8
```
Обратите также внимание на то, что директива
```
using Counter;
```
делает видимым все содержимое пространства имен Counter. Это дает возможность
обращаться к классам CountDown и CountUp непосредственно, т.е. без дополнительно­
го указания пространства имен. При этом разделение пространства имен Counter на
две части не имеет никакого значения.

### Вложенные пространства имен
Одно пространство имен может быть вложено в другое. В качестве примера рас­
смотрим следующую программу.
```
// Вложенные пространства имен.
using System;

namespace NS1 {
    class ClassA {
        public ClassA() {
            Console.WriteLine("Конструирование класса ClassA");
        }
    }

    namespace NS2 { // вложенное пространство имен
        class ClassB {
            public ClassB() {
                Console.WriteLine("Конструирование класса ClassB");
            }
        }
    }
}

class NestedNSDemo {
    static void Main() {
        NS1.ClassA a = new NS1.ClassA();

        // NS2.ClassB b = new NS2.ClassB(); // Неверно!!! Пространство NS2 невидимо

        NS1.NS2.ClassB b = new NS1.NS2.ClassB(); // Верно!
    }
}
```
Выполнение этой программы дает следующий результат.
```
Конструирование класса ClassA
Конструирование класса ClassB
```
В этой программе пространство имен NS2 вложено в пространство имен NS1. По­
этому для обращения к классу ClassB необходимо дополнительно указать простран­
ства имен NS1 и NS2. Указания одного лишь пространства имен NS2 для этого недоста­
точно. Как следует из приведенного выше примера, пространства имен дополнитель­
но указываются через точку. Следовательно, для обращения к классу ClassB в методе
Main() необходимо указать его полное имя — NS1.NS2.ClassB.

Пространства имен могут быть вложенными больше, чем на два уровня. В этом слу­
чае член вложенного пространства имен должен быть дополнительно определен с по­
мощью всех охватывающих пространств имен.

Вложенные пространства имен можно указать в одном операторе namespace, раз­
делив их точкой. Например, вложенные пространства имен
```
namespace OuterNS {
    namespace InnerNS {
        // ...
    }
}
```
могут быть указаны следующим образом.
```
namespace OuterNS.InnerNS {
    // ...
}
```

### Глобальное пространство имен
Если в программе не объявлено пространство имен, то по умолчанию используется
глобальное пространство имен. Именно поэтому в примерах программ, представлен­
ных в предыдущих главах книги, не нужно было обращаться для этой цели к клю­
чевому слову namespace. Глобальное пространство удобно для коротких программ,
как в примерах из этой книги, но в большинстве случаев реальный код содержится в
объявляемом пространстве имен. Главная причина инкапсуляции кода в объявляемом
пространстве имен — предотвращение конфликтов имен. Пространства имен служат
дополнительным средством, помогающим улучшить организацию программ и при­
способить их к работе в сложной среде с современной сетевой структурой.

### Применение описателя псевдонима пространства имен ::
Пространства имен помогают предотвратить конфликты имен, но не устранить их
полностью. Такой конфликт может, в частности, произойти, когда одно и то же имя
объявляется в двух разных пространствах имен и затем предпринимается попытка
сделать видимыми оба пространства. Допустим, что два пространства имен содержат
класс MyClass. Если попытаться сделать видимыми оба пространства имен с помо­
щью директив using, то имя MyClass из первого пространства вступит в конфликт с
именем MyClass из второго пространства, обусловив появление ошибки неоднознач­
ности. В таком случае для указания предполагаемого пространства имен явным обра­
зом можно воспользоваться описателем псевдонима пространства имен ::.

Ниже приведена общая форма оператора ::.
```
псевдоним_пространства_имен::идентификатор
```
Здесь псевдоним_пространства_имен обозначает конкретное имя псевдонима про­
странства имен, а идентификатор — имя члена этого пространства.

Для того чтобы стало понятнее назначение описателя псевдонима пространства
имен, рассмотрим следующий пример программы, в которой создаются два простран­
ства имен, Counter и AnotherCounter, и в обоих пространствах объявляется класс
CountDown. Затем оба пространства имен становятся видимыми с помощью директив
using. И наконец, в методе Main() предпринимается попытка получить экземпляр
объекта типа CountDown.
```
// Продемонстрировать необходимость описателя ::.
using System;
// Использовать оба пространства имен Counter и AnotherCounter.
using Counter;
using AnotherCounter;

// Объявить пространство имен для счетчиков.
namespace Counter {
    // Простой вычитающий счетчик.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        // ...
    }
}

// Объявить еще одно пространство имен для счетчиков.
namespace AnotherCounter {
    // Объявить еще один класс CountDown, принадлежащий
    // пространству имен AnotherCounter.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        // ...
    }
}

class WhyAliasQualifier {
    static void Main() {
        int i;

        // Следующая строка, по существу, неоднозначна!
        // Неясно, делается ли в ней ссылка на класс CountDown
        // из пространства имен Counter или AnotherCounter?
        CountDown cd1 = new CountDown(10); // Ошибка! ! !

        // ...
    }
}
```
Если попытаться скомпилировать эту программу, то будет получено сообщение
об ошибке, уведомляющее о неоднозначности в следующей строке кода из метода
Main().
```
CountDown cd1 = new CountDown(10); // Ошибка!!!
```
Причина подобной неоднозначности заключается в том, что в обоих пространствах
имен, Counter и AnotherCounter, объявлен класс CountDown и оба пространства
сделаны видимыми. Поэтому неясно, к какому именно варианту класса CountDown
следует отнести приведенное выше объявление. Для устранения подобного рода недо­
разумений и предназначен описатель ::.

Для того чтобы воспользоваться описателем ::, необходимо сначала определить
псевдоним для пространства имен, которое требуется описать, а затем дополнить опи­
сание неоднозначного элемента этим псевдонимом. Ниже приведен вариант преды­
дущего примера программы, в котором устраняется упомянутая выше неоднознач­
ность.
```
// Продемонстрировать применение описателя ::.
using System;
using Counter;
using AnotherCounter;

// Присвоить классу Counter псевдоним Ctr.
using Ctr = Counter;

// Объявить пространство имен для счетчиков.
namespace Counter {
    // Простой вычитающий счетчик.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        // ...
    }
}

// Объявить еще одно пространство имен для счетчиков.
namespace AnotherCounter {
    // Объявить еще один класс CountDown, принадлежащий
    // пространству имен AnotherCounter.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        // ...
    }
}

class AliasQualifierDemo {
    static void Main() {
        // Здесь оператор :: разрешает конфликт, предписывая компилятору
        // использовать класс CountDown из пространства имен Counter.
        Ctr::CountDown cd1 = new Ctr::CountDown(10);
        // ...
    }
}
```
В этом варианте программы для класса Counter сначала указывается псевдоним
Ctr в следующей строке кода.
```
using Ctr = Counter;
```
А затем этот псевдоним используется в методе Main() для дополнительного опи­
сания класса CountDown, как показано ниже.
```
Ctr::CountDown cd1 = new Ctr::CountDown(10);
```
Описатель :: устраняет неоднозначность, поскольку он явно указывает на то, что
следует обратиться к классу CountDown из пространства Ctr, а фактически — Counter.
Именно это и делает теперь программу пригодной для компиляции.

Описатель :: можно также использовать вместе с предопределенным идентифика­
тором global для ссылки на глобальное пространство имен. Например, в приведен­
ной ниже программе класс CountDown объявляется как в пространстве имен Counter,
так и в глобальном пространстве имен. А для доступа к варианту класса CountDown в
глобальном пространстве имен служит предопределенный псевдоним global.
```
// Использовать псевдоним глобального пространства имен.
using System;

// Присвоить классу Counter псевдоним Ctr.
using Ctr = Counter;
// Объявить пространство имен для счетчиков.

namespace Counter {
// Простой вычитающий счетчик.
    class CountDown {
        int val;

        public CountDown(int n) {
            val = n;
        }

        // ...
    }
}

// Объявить еще один класс CountDown, принадлежащий
// глобальному пространству имен.
class CountDown {
    int val;

    public CountDown(int n) {
        val = n;
    }

    // ...
}

class GlobalAliasQualifierDemo {
    static void Main() {
        // Здесь описатель :: предписывает компилятору использовать
        // класс CountDown из пространства имен Counter.
        Ctr::CountDown cd1 = new Ctr::CountDown(10);

        // Далее создать объект класса CountDown из
        // глобального пространства имен.
        global::CountDown cd2 = new global::CountDown(10);

        // ...
    }
}
```
Обратите внимание на то, что идентификатор global служит для доступа к классу
CountDown из используемого по умолчанию пространства имен.
```
global::CountDown cd2 = new global::CountDown(10);
```
Этот подход можно распространить на любую ситуацию, в которой требуется ука­
зывать используемое по умолчанию пространство имен.

И последнее: описатель псевдонима пространства имен можно применять вместе с
псевдонимами типа extern, как будет показано в главе 20.

## Препроцессор
В С# определен ряд директив препроцессора, оказывающих влияние на интерпре­
тацию исходного кода программы компилятором. Эти директивы определяют поря­
док интерпретации текста программы перед ее трансляцией в объектный код в том
исходном файле, где они появляются. Термин директива препроцессора появился в связи
с тем, что подобные инструкции по традиции обрабатывались на отдельной стадии
компиляции, называемой препроцессором. Обрабатывать директивы на отдельной ста­
дии препроцессора в современных компиляторах уже не нужно, но само ее название
закрепилось.

Ниже приведены директивы препроцессора, определенные в С#.

|            |         |        |          |
|------------|---------|--------|----------|
| #define    | #elif   | #else  | #endif   |
| #endregion | #error  | #if    | #line    |
| #pragma    | #region | #undef | #warning |

Все директивы препроцессора начинаются со знака #. Кроме того, каждая директи­
ва препроцессора должна быть выделена в отдельную строку кода.

Принимая во внимание современную объектно-ориентированную архитектуру
языка С#, потребность в директивах препроцессора в нем не столь велика, как в языках
программирования предыдущих поколений. Тем не менее они могут быть иногда по­
лезными, особенно для условной компиляции. В этом разделе все директивы препро­
цессора рассматриваются по очереди.

### Директива #define
Директива #define определяет последовательность символов, называемую иденти­
фикатором. Присутствие или отсутствие идентификатора может быть определено с
помощью директивы #if или #elif и поэтому используется для управления процес­
сом компиляции. Ниже приведена общая форма директивы #define.
```
#define идентификатор
```
Обратите внимание на отсутствие точки с запятой в конце этого оператора. Между
директивой #define и идентификатором может быть любое количество пробелов, но
после самого идентификатора должен следовать только символ новой строки. Так, для
определения идентификатора EXPERIMENTAL служит следующая директива.
```
#define EXPERIMENTAL
```

**ПРИМЕЧАНИЕ**
В C/C++ директива #define может использоваться для подстановки исходного текста, на­
пример для определения имени значения, а также для создания макрокоманд, похожих на
функции. А в C# такое применение директивы #define не поддерживается. В этом языке
директива #define служит только для определения идентификатора.

### Директивы #if и #endif
Обе директивы, #if и #endif, допускают условную компиляцию последовательно­
сти кода в зависимости от истинного результата вычисления выражения, включающе­
го в себя один или несколько идентификаторов. Идентификатор считается истинным,
если он определен, а иначе — ложным. Так, если идентификатор определен директивой #define, то он будет оценен как истинный. Ниже приведена общая форма директивы #if.
```
#if идентификаторное_выражение
	последовательность операторов
#endif
```
Если идентификаторное_выражение, следующее после директивы #if, истинно,
то компилируется код (последовательность операторов), указываемый между ним
и директивой #endif. В противном случае этот промежуточный код пропускается.
Директива #endif обозначает конец блока директивы #if.

Идентификаторное выражение может быть простым, как наименование идентифи­
катора. В то же время в нем разрешается применение следующих операторов: !, ==,
!=, && и ||, а также круглых скобок.

Ниже приведен пример применения упомянутых выше директив.
```
// Продемонстрировать применение директив
// #if, #endif и #define.
#define EXPERIMENTAL

using System;

class Test {
	static void Main() {
	#if EXPERIMENTAL
		Console.WriteLine("Компилируется для экспериментальной версии.");
	#endif
		Console.WriteLine("Присутствует во всех версиях.");
	}
}
```
Этот код выдает следующий результат.
```
Компилируется для экспериментальной версии.
Присутствует во всех версиях.
```
В приведенном выше коде определяется идентификатор EXPERIMENTAL. Поэтому
когда в этом коде встречается директива #if, идентификаторное выражение вычис­
ляется как истинное и затем компилируется первый оператор, содержащий вызов
метода WriteLine(). Если же удалить определение идентификатора EXPERIMENTAL
и перекомпилировать данный код, то первый оператор, содержащий вызов метода
WriteLine(), не будет скомпилирован, поскольку идентификаторное выражение ди­
рективы #if вычисляется как ложное. Но второй оператор, содержащий вызов метода
WriteLine(), компилируется в любом случае, потому что он не входит в блок дирек­
тивы #if.

Как пояснялось выше, в директиве #if допускается указывать идентификаторное
выражение. В качестве примера рассмотрим следующую программу.
```
// Использовать идентификаторное выражение.
#define EXPERIMENTAL
#define TRIAL

using System;

class Test {
	static void Main() {
		#if EXPERIMENTAL
			Console.WriteLine("Компилируется для экспериментальной версии.");
		#endif
		#if EXPERIMENTAL && TRIAL
			Console.Error.WriteLine ("Проверка пробной экспериментальной
				версии.");
		#endif
		Console.WriteLine("Присутствует во всех версиях.");
	}
}
```
Эта программа дает следующий результат.
```
Компилируется для экспериментальной версии.
Проверка пробной экспериментальной версии.
Присутствует во всех версиях.
```
В данном примере определены два идентификатора: EXPERIMENTAL и TRIAL. Вто­
рой оператор, содержащий вызов метода WriteLine(), компилируется лишь в том
случае, если определены оба идентификатора.

Для компилирования кода в том случае, если идентификатор не определен, можно
воспользоваться оператором !, как в приведенном ниже примере.
```
#if !EXPERIMENTAL
	Console.WriteLine("Этот код не экспериментальный!");
#endif
```
Вызов метода будет скомпилирован только в том случае, если идентификатор
EXPERIMENTAL не определен.

### Директивы #else и #elif
Директива #else действует аналогично условному оператору else языка С#, опре­
деляя альтернативный ход выполнения программы, если этого не может сделать ди­
ректива #if. С учетом директивы #else предыдущий пример программы может быть
расширен следующим образом.
```
// Продемонстрировать применение директивы #else.
#define EXPERIMENTAL

using System;

class Test {
	static void Main() {
		#if EXPERIMENTAL
			Console.WriteLine("Компилируется для экспериментальной версии.");
		#else
			Console.WriteLine("Компилируется для окончательной версии.");
		#endif
		#if EXPERIMENTAL && TRIAL
			Console.Error.WriteLine("Проверка пробной экспериментальной
									версии.");
		#else
			Console.Error.WriteLine("Это не пробная экспериментальная версия.");
		#endif
		Console.WriteLine("Присутствует во всех версиях.");
	}
}
```
Вот к какому результату приводит выполнение этой программы.
```
Компилируется для экспериментальной версии.
Это не пробная экспериментальная версия.
Присутствует во всех версиях.
```
В данном примере идентификатор TRIAL не определен, и поэтому часть #else вто­
рой условной последовательности кода не компилируется.

Обратите внимание на то, что директива #else обозначает конец блока дирек­
тивы #if и в то же время — начало блока самой директивы #else. Это необходи­
мо потому, что с любой директивой #if может быть связана только одна директива #endif. Более того, с любой директивой #if может быть связана только одна дирек­
тива #else.

Обозначение #elif означает "иначе если", а сама директива #elif определяет по­
следовательность условных операций if-else-if для многовариантной компиляции.
После директивы #elif указывается идентификаторное выражение. Если это выраже­
ние истинно, то компилируется следующий далее кодовый блок, а остальные выраже­
ния директивы #elif не проверяются. В противном случае проверяется следующий
по порядку блок. Если же ни одну из директив #elif не удается выполнить, то при
наличии директивы #else выполняется последовательность кода, связанная с этой ди­
рективой, а иначе не компилируется ни один из кодовых блоков директивы #if.

Ниже приведена общая форма директивы #elif.
```
#if идентификаторное_выражение
	последовательность операторов
#elif идентификаторное_выражение
	последовательность операторов
#elif идентификаторное_выражение
	последовательность операторов
	// ...
#endif
```
В приведенном ниже примере демонстрируется применение директивы #elif.
```
// Продемонстрировать применение директивы #elif.
#define RELEASE

using System;

class Test {
	static void Main() {
		#if EXPERIMENTAL
			Console.WriteLine("Компилируется для экспериментальной версии.");
		#elif RELEASE
			Console.WriteLine("Компилируется для окончательной версии.");
		#else
			Console.WriteLine("Компилируется для внутреннего тестирования.");
		#endif
		#if TRIAL && !RELEASE
			Console.WriteLine("Пробная версия.");
		#endif
		Console.WriteLine("Присутствует во всех версиях.");
	}
}
```
Этот код выдает следующий результат.
```
Компилируется для окончательной версии.
Присутствует во всех версиях.
```

### Директива #undef
С помощью директивы #undef удаляется определенный ранее идентификатор.
Это, по существу, означает, что он становится "неопределенным". Ниже приведена об­
щая форма директивы #undef.
```
#undef идентификатор
```
Рассмотрим следующий пример кода.
```
#define SMALL
#if SMALL
	// ...
#undef SMALL
// теперь идентификатор SMALL не определен.
```
После директивы #undef идентификатор SMALL уже оказывается неопреде­
ленным.

Директива #undef применяется главным образом для локализации идентификато­
ров только в тех фрагментах кода, в которых они действительно требуются.

### Директива #error
Директива #error вынуждает компилятор прервать компиляцию. Она служит в
основном для отладки. Ниже приведена общая форма директивы #error.
```
#error сообщение_об_ошибке
```
Когда в коде встречается директива #error, выводится сообщение об ошибке. На­
пример, когда компилятору встречается строка кода
```
#error Это тестовая ошибка!
```
компиляция прерывается и выводится сообщение "Это тестовая ошибка!".

### Директива #warning
Директива #warning действует аналогично директиве #error, за исключением
того, что она выводит предупреждение, а не ошибку. Следовательно, компиляция не
прерывается. Ниже приведена общая форма директивы #warning.
```
#warning предупреждающее_сообщение
```

### Директива #line
Директива #line задает номер строки и имя файла, содержащего эту директиву.
Номер строки и имя файла используются при выводе ошибок или предупреждений
во время компиляции. Ниже приведена общая форма директивы #line.
```
#line номер "имя_файла"
```
Имеются еще два варианта директивы #line. В первом из них она указывается с
ключевым словом default, обозначающим возврат нумерации строк в исходное со­
стояние, как в приведенном ниже примере.
```
#line default
```
А во втором варианте директива #line указывается с ключевым словом hidden.
При пошаговой отладке программы строки кода, находящиеся между директивой
```
#line hidden
```
и следующей директивой #line без ключевого слова hidden, пропускаются отладчиком.

### Директивы #region и #endregion
С помощью директив #region и #endregion определяется область, которая раз­
ворачивается или сворачивается при структурировании исходного кода в интегриро­
ванной среде разработки Visual Studio. Ниже приведена общая форма этих директив:
```
#region текст
	// последовательность кода
#endregion текст
```
где текст обозначает необязательную символьную строку.

### Директива #pragma
С помощью директивы #pragma инструкции задаются компилятору в виде опций.
Ниже приведена общая форма этой директивы:
```
#pragma опция
```
где опция обозначает инструкцию, передаваемую компилятору.

В текущей версии C# предусмотрены две опции для директивы #pragma. Первая
из них, warning, служит для разрешения или запрета отдельных предупреждений со
стороны компилятора. Она принимает две формы:
```
#pragma warning disable предупреждения
#pragma warning restore предупреждения
```
где предупреждения обозначает разделяемый запятыми список номеров предупре­
ждений. Для отмены предупреждения используется опция disable, а для его разре­
шения — опция restore.

Например, в приведенной ниже директиве #pragma запрещается выдача предупре­
ждения №168, уведомляющего о том, что переменная объявлена, но не используется.
```
#pragma warning disable 168
```
Второй для директивы #pragma является опция checksum. Она служит для форми­
рования контрольной суммы в проектах ASP.NET. Ниже приведена ее общая форма:
```
#pragma checksum "имя_файла" "{GUID}" "контрольная_сумма"
```
где имя_файла обозначает конкретное имя файла; GUID — глобально уникальный
идентификатор, с которым связано имя_файла; контрольная_сумма — шестнадцате­
ричное число, представляющее контрольную сумму. У этой контрольной суммы долж­
но быть четное число цифр.

## Сборки и модификатор доступа internal
Сборка является неотъемлемой частью программирования на С#. Она представляет
собой один или несколько файлов, содержащих все необходимые сведения о развер­
тывании программы и ее версии. Сборки составляют основу среды .NET. Они предо­
ставляют механизмы для надежного взаимодействия компонентов, межъязыковой воз­
можности взаимодействия и управления версиями. Кроме того, сборки определяют
область действия программного кода.

Сборка состоит из четырех разделов. Первый раздел представляет собой деклара­
цию сборки. Декларация содержит сведения о самой сборке. К этой информации от­
носится, в частности, имя сборки, номер ее версии, сведения о соответствии типов
и параметры культурной среды (язык и региональные стандарты). Второй раздел
сборки содержит метаданные типов, т.е. сведения о типах данных, используемых в
программе. Среди прочих преимуществ метаданные типов способствуют межъязы­
ковой возможности взаимодействия. Третий раздел сборки содержит программный
код в формате MSIL (Microsoft Intermediate Language — промежуточный язык корпо­
рации Microsoft). И четвертый раздел сборки содержит ресурсы, используемые про­
граммой.

Правда, при программировании на C# сборки получаются автоматически, требуя
от программирующего лишь минимальных усилий. Дело в том, что исполняемый
файл, создаваемый во время компиляции программы на С#, на самом деле представ­
ляет собой сборку, содержащую исполняемый код этой программы, а также другие
виды информации. Таким образом, когда компилируется программа на С#, сборка
получается автоматически.

У сборок имеется много других особенностей, и с ними связано немало актуальных
вопросов программирования, но, к сожалению, их обсуждение выходит за рамки этой
книги. Ведь сборки являются неотъемлемой частью процесса разработки программ­
ного обеспечения в среде .NET, но формально они не относятся к средствам языка С#.
Тем не менее в C# имеется одно средство, непосредственно связанное со сборкой. Это
модификатор доступа internal, рассматриваемый в следующем разделе.

### Модификатор доступа internal
Помимо модификаторов доступа public, private и protected, использовав­
шихся в представленных ранее примерах программ, в C# предусмотрен также моди­
фикатор доступа internal. Этот модификатор определяет доступность члена во всех
файлах сборки и его недоступность за пределами сборки. Проще говоря, о члене, обо­
значенном как internal, известно только в самой программе, но не за ее пределами.
Модификатор доступа internal особенно полезен для создания программных ком­
понентов.

Модификатор доступа internal можно применять к классам и их членам, а также
к структурам и членам структур. Кроме того, модификатор internal разрешается
использовать в объявлениях интерфейсов и перечислений.

Из модификаторов protected и internal можно составить спаренный модифи­
катор доступа protected internal. Уровень доступа protected internal может
быть задан только для членов класса. Член, объявленный как protected internal,
доступен лишь в пределах собственной сборки или для производных типов.

Ниже приведен пример применения модификатора доступа internal.
```
// Использовать модификатор доступа internal.
using System;

class InternalTest {
	internal int x;
}

class InternalDemo {
	static void Main() {
		InternalTest ob = new InternalTest();

		ob.x = 10; // доступно, потому что находится в том же файле

		Console.WriteLine("Значение ob.x: " + ob.x);
	}
}
```
В классе InternalTest поле х объявляется как internal. Это означает, что поле х
доступно в самой программе, но, как показывает код класса InternalDemo, оно недо­
ступно за пределами программы.