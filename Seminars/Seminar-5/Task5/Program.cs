// **Задача 37:** 
// Найдите произведение пар чисел в одномерном массиве. 
// Парой считаем первый и последний элемент, второй и предпоследний и т.д. 
// Результат запишите в новом массиве.
// [1 2 3 4 5] -> 5 8 3
// [6 7 3 6] -> 36 21


using static System.Console;
Clear();

Write("Введите количество элементов в массиве: ");
int[] RandomGeneratedResult = GetMyRandomArray(int.Parse(ReadLine()!));
WriteLine($"Результат произведения пар чисел в одномерном массиве: [{String.Join(",", MultiplicationOfArrayElements(RandomGeneratedResult))}]");


// Алгоритм: 
// Обращаемся к элементам слева в массиве через индекс и в конце массива через длину массива и идём навстречу с разных концов
// Последовательно умножаем первый и последний элемент - кладём результат  в 1 ячейку нового массива, потом  второй и предпоследний - кладём результат  во 2-ую ячейку нового массива и т.д.  пока не дойдём до середины изначального массива(если он нечётный) 
// Берём оставшийся элемент и ставим в  самый конец нового массива. Если изначально массив содержит чётное количество элементов  - то на каждый элемент есть пара и их просто надо последовательно перемножить.
//  В С#  при целочисленном делении (int number1 / int number2) округление идёт в наименьшую сторону поэтому мы можем всегда обратиться к среднему элементу любого нечётного по количеству элементов массива
//  Обращение к элементу массива как всегда  идёт через индекс который для нашего среднего элемента всегда будет равен длине нашего массива разделённой пополам
int[] MultiplicationOfArrayElements(int[] array)
{
    int OurFinalArrayPossibleLength = array.Length % 2 == 0 ? array.Length / 2 : array.Length / 2 + 1;
    int[] ResultArray = new int[OurFinalArrayPossibleLength];
    for (int i = 0; i < ResultArray.Length; i++)
    {
        ResultArray[i] = array[i] * array[(array.Length - 1) - i];
    }
    if (array.Length % 2 == 1) // можно было использовать  if (array.Length % 2 !=0) 
    {
        ResultArray[OurFinalArrayPossibleLength - 1] = array[array.Length / 2];
    }
    return ResultArray;
}
//  Можно было взять немного другой алгоритм внутри нашего цикла for
//  Мы идём на встречу друг другу с разных сторон изначального массива  и последовательно умножаем элементы пока они не равны друг другу и складываем результаты в новый массив
//  Когда мы пришли в одно и тоже место и следуя как слева так и справа (это и есть средний элемент в  массиве с нечётным количеством элементов)
//  мы говорим что просто возьми это число и положи в наш массив с ответами, поскольку момент прихода в точку схождения это последняя итерация в нашем цикле
//  или  же говоря на языке маглов - последнее действие в нашей цепочке проделанной работы - то закономерно мы как раз и положим это число в самый конец нашего массива с ответами.

// if (array[i] !=array[(array.Length - 1) - i])
// {
//     ResultArray[i] = array[i] * array[(array.Length - 1) - i];
// }
// else
// {
//     ResultArray[i] = array[i]
// }




int[] GetMyRandomArray(int size)
{
    int[] array = new int[size];
    for (int i = 0; i < size; i++)
    {
        array[i] = new Random().Next(-10, 11);
    }
    WriteLine($"Одномерный массив случайных чисел в диапазоне [-10,10] выглядит так: [{String.Join(",", array)}]");
    return array;
}
